# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
# all figurate (polygonal) numbers and are generated by the following formulae:
#
# Triangle    P₃(n) = n(n+1)/2   1, 3, 6, 10, 15, ...
# Square      P₄(n) = n²         1, 4, 9, 16, 25, ...
# Pentagonal  P₅(n) = n(3n−1)/2  1, 5, 12, 22, 35, ...
# Hexagonal   P₆(n) = n(2n−1)    1, 6, 15, 28, 45, ...
# Heptagonal  P₇(n) = n(5n−3)/2  1, 7, 18, 34, 55, ...
# Octagonal   P₈(n) = n(3n−2)    1, 8, 21, 40, 65, ...
#
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
# interesting properties.
#
# 1. The set is cyclic, in that the last two digits of each number is the first
#    two digits of the next number (including the last number with the first).
# 2. Each polygonal type: triangle (P₃(127)8128), square (P₄(91)=8281), and
#    pentagonal (P₅(44)=2882), is represented by a different number in the set.
# 3. This is the only set of 4-digit numbers with this property.
#
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which
# each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
# octagonal, is represented by a different number in the set.

require_relative '../core_ext/math'

@polygonal_numbers = []
CYCLE_LENGTH = 6

# calculate all 4-digit polygonal numbers for s = 3..8
[*0...CYCLE_LENGTH].each do |s|
  @polygonal_numbers[s] = []
  1.upto(Float::INFINITY) do |n|
    break if (psn = Math.nth_polygonal(s + 3, n)) > 9999
    # split into digits to make comparisons easier
    @polygonal_numbers[s] << psn.digits if psn > 999
  end
end

[*0...CYCLE_LENGTH].permutation(CYCLE_LENGTH).each do |chain_order|
  polygonals = Marshal.load(Marshal.dump(@polygonal_numbers)) # deep clone
  bucket_sizes = []; index = 0; next_index = 1

  # cycle through the polygonals in the given chain_order, removing numbers that
  # don't have a match in the neighboring buckets.
  while (prev_index = index; index = next_index; next_index = (index + 1) % CYCLE_LENGTH) do
    bucket_sizes << polygonals.map(&:length)
    polygonals[chain_order[index]].select! do |w,x,y,z|
      polygonals[chain_order[next_index]].any?{|a,b,_,_| a == y && b == z} &&
        polygonals[chain_order[prev_index]].any?{|_,_,c,d| c == w && d == x}
    end
    # break when we loop the whole chain without removing anything
    break if bucket_sizes[-CYCLE_LENGTH] == polygonals.map(&:length)
  end

  unless polygonals.map(&:length).any?(&:zero?) # success!
    puts polygonals.map{|digits| digits.join.to_i}.inject(&:+)
    exit
  end
end

# => 28684
# real  0m0.086s
# user  0m0.075s
# sys   0m0.008s
